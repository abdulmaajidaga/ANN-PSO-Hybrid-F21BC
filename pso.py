import numpy as np


class ParticleSwarm(object):
    def  __init__(self, num_particles, num_informants, objective_function, particle_length_continuous, num_discrete_variables = None, num_discrete_options = None, alpha = 0.9, beta = 0.8, gamma = 0.5, delta = 0.8, epsilon = 0.25, particles = None ):
        self.num_particles = num_particles # Number of particles in the swarm (swarm size)
        self.particle_length_continuous = particle_length_continuous # Length in the continuous search space
        self.particle_length_discrete = num_discrete_variables * num_discrete_options # Length in the discrete search space
        self.particle_length = particle_length_continuous + self.particle_length_discrete # Total particle length
        self.num_discrete_variables = num_discrete_variables # Number of discrete variables 
        self.num_discrete_options = num_discrete_options # Number of options per discrete variable
        self.objective_function = objective_function # Objective function to be minimized
        
        self.alpha = alpha # α (alpha): proportion of previous velocity to be retained 
        self.beta = beta # β (beta): proportion of personal best to be retained 
        self.gamma = gamma # γ (gamma): proportion of informants' best to be retained 
        self.delta = delta # δ (delta): proportion of global best to be retained 
        self.epsilon = epsilon # ε (epsilon): jump size or step size of a particle 
        
        if particles is not None:
            self.particle_array = particles
        else:
            self.particle_array = np.random.uniform(size=(num_particles, self.particle_length)) # Stores particle positions

        
        self.velocity_array = np.random.rand(num_particles, self.particle_length) # Stores particle speeds/velocities at each particle index


        self.personal_best_array = np.copy(self.particle_array) # Stores personal best positions at each particle index
        self.informants_best_array = self.create_informants_best_array(num_informants) # Stores informants best positions at each particles index
        self.fitness_values_array =  self.objective_function(self.particle_array) # Stores fitness values at each particle index
        
        global_best_idx = np.argmin(self.fitness_values_array)
        self.Gbest = self.particle_array[global_best_idx] # Stores the global best particle position
        self.Gbest_value = self.fitness_values_array[global_best_idx] # Stores the global best particle fitness value
        print(f"Initial Global Best Value: {self.Gbest_value}")
        
        

    
    # Generated by ChatGPT
    def create_informants_best_array(self, num_informants):
        """
        Randomly selects a number of informant particles for each particle,
        evaluates their fitness, and stores the best informant's position
        at the corresponding index in informants_best_array.

        Parameters
        ----------
        num_informants : int
            Number of informants (neighbors) to select per particle.

        Effects
        -------
        Creates a new attribute:
            informants_best_array : np.ndarray
                Shape (num_particles, particle_length), where index i contains
                the fittest informant particle for source particle i.
        """
        # --- Initialize the container for best informants per particle ---
        informants_best_array = np.zeros_like(self.particle_array)

        # --- Loop over each source particle ---
        for i in range(self.num_particles):

            # Select random unique indices excluding the current particle
            possible_indices = [j for j in range(self.num_particles) if j != i]
            informant_indices = np.random.choice(possible_indices,
                                                size=min(num_informants, len(possible_indices)),
                                                replace=False)
            # Extract the informant particles
            informants = self.particle_array[informant_indices]


            # Evaluate their fitness
            local_fitness_values_array = self.objective_function(informants)

            # Find the best informant among them
            best_idx_local = np.argmin(local_fitness_values_array)
            informant_best = informants[best_idx_local]

            # Store best informant position in array
            informants_best_array[i] = informant_best
            #print(f"Particle {i}: Informants indices {informant_indices}, Best informant index {best_idx_local}, Fitness {local_fitness_values_array[best_idx_local]}")

        # Optional: return for inspection
        return informants_best_array

            
            
    def _update(self):

        cognitive_component_array =  np.random.uniform(low = 0, high = self.beta, size=(self.num_particles, self.particle_length))
        local_social_component_array = np.random.uniform(low = 0, high = self.gamma, size=(self.num_particles, self.particle_length))
        global_social_component_array = np.random.uniform(low = 0, high = self.delta, size=(self.num_particles, self.particle_length))

        self.velocity_array = self.alpha * self.velocity_array + cognitive_component_array * (self.personal_best_array - self.particle_array) + local_social_component_array * ( self.informants_best_array - self.particle_array) + global_social_component_array * (self.Gbest - self.particle_array)
        self.particle_array = self.particle_array + self.epsilon * self.velocity_array
                
        
        # Generated by ChatGPT
        # Split index positions
        num_c = self.particle_length_continuous       # continuous variable count
        num_d = self.num_discrete_variables         # discrete variable count
        num_o = self.num_discrete_options           # options per discrete variable

        # Extract discrete section and reshape
        discrete_section = self.particle_array[:, num_c:].reshape(self.num_particles, num_d, num_o)

        # Normalize each probability distribution along the last axis
        discrete_sum = discrete_section.sum(axis=2, keepdims=True)
        discrete_sum[discrete_sum == 0] = 1.0   # avoid division by zero
        discrete_section /= discrete_sum

        # Write it back inline
        self.particle_array[:, num_c:] = discrete_section.reshape(self.num_particles, -1)

            
        
        self.fitness_values_array = self.objective_function(self.particle_array)
        improved_particles_idx = self.fitness_values_array < self.objective_function(self.personal_best_array)
        self.personal_best_array[improved_particles_idx] = self.particle_array[improved_particles_idx]
        
        global_best_idx = np.argmin(self.fitness_values_array)
        if self.fitness_values_array[global_best_idx] < self.Gbest_value:
            self.Gbest = self.particle_array[global_best_idx]
            self.Gbest_value = self.fitness_values_array[global_best_idx]
            
    
    


 
